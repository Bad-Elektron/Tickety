import '../../../core/errors/errors.dart';
import '../../../core/models/models.dart';
import '../../../core/services/services.dart';
import '../models/event_model.dart';
import '../models/ticket_availability.dart';
import '../models/ticket_type.dart';
import 'event_mapper.dart';
import 'event_repository.dart';

/// Data class for creating ticket types (used in event creation).
class TicketTypeInput {
  final String name;
  final String? description;
  final int priceCents;
  final int? maxQuantity;

  const TicketTypeInput({
    required this.name,
    required this.priceCents,
    this.description,
    this.maxQuantity,
  });
}

const _tag = 'EventRepository';

/// Supabase implementation of [EventRepository].
///
/// Fetches and manages events from the Supabase PostgreSQL database.
class SupabaseEventRepository implements EventRepository {
  static const _tableName = 'events';

  final _client = SupabaseService.instance.client;

  @override
  Future<PaginatedResult<EventModel>> getUpcomingEvents({
    String? category,
    String? city,
    int page = 0,
    int pageSize = 20,
  }) async {
    AppLogger.debug(
      'Fetching upcoming events (category: $category, city: $city, page: $page, pageSize: $pageSize)',
      tag: _tag,
    );

    // Build query with filters first, then ordering
    var query = _client
        .from(_tableName)
        .select()
        .isFilter('deleted_at', null)
        .gte('date', DateTime.now().toUtc().toIso8601String());

    if (category != null) {
      query = query.eq('category', category);
    }
    if (city != null) {
      query = query.eq('city', city);
    }

    // Apply ordering after all filters
    final orderedQuery = query.order('date', ascending: true);

    // Calculate range for pagination (fetch one extra to detect hasMore)
    final from = page * pageSize;
    final to = from + pageSize;

    final response = await orderedQuery.range(from, to);

    final allItems = (response as List<dynamic>)
        .map((json) => EventMapper.fromJson(json as Map<String, dynamic>))
        .toList();

    // Check if we got more than pageSize (meaning there are more pages)
    final hasMore = allItems.length > pageSize;
    final events = hasMore ? allItems.take(pageSize).toList() : allItems;

    AppLogger.debug(
      'Fetched ${events.length} upcoming events (hasMore: $hasMore)',
      tag: _tag,
    );

    return PaginatedResult(
      items: events,
      page: page,
      pageSize: pageSize,
      hasMore: hasMore,
    );
  }

  @override
  Future<EventModel?> getEventById(String id) async {
    AppLogger.debug('Fetching event by ID: $id', tag: _tag);

    final response = await _client
        .from(_tableName)
        .select()
        .eq('id', id)
        .isFilter('deleted_at', null)
        .maybeSingle();

    if (response == null) {
      AppLogger.debug('Event not found: $id', tag: _tag);
      return null;
    }
    return EventMapper.fromJson(response);
  }

  @override
  Future<List<EventModel>> getFeaturedEvents({int limit = 5}) async {
    AppLogger.debug('Fetching featured events (limit: $limit)', tag: _tag);

    // For now, just get the nearest upcoming events as featured
    // In production, you might have a "featured" flag or algorithm
    final response = await _client
        .from(_tableName)
        .select()
        .isFilter('deleted_at', null)
        .gte('date', DateTime.now().toUtc().toIso8601String())
        .order('date', ascending: true)
        .limit(limit);

    final events = (response as List<dynamic>)
        .map((json) => EventMapper.fromJson(json as Map<String, dynamic>))
        .toList();

    AppLogger.debug('Fetched ${events.length} featured events', tag: _tag);
    return events;
  }

  @override
  Future<EventModel> createEvent(EventModel event) async {
    final userId = SupabaseService.instance.currentUser?.id;
    if (userId == null) {
      AppLogger.warning('Attempted to create event without authentication', tag: _tag);
      throw StateError('Must be authenticated to create events');
    }

    AppLogger.debug('Creating event: ${event.title}', tag: _tag);

    final data = EventMapper.toJson(event);
    data['organizer_id'] = userId;

    final response =
        await _client.from(_tableName).insert(data).select().single();

    final created = EventMapper.fromJson(response);
    AppLogger.info('Event created: ${created.id} - ${created.title}', tag: _tag);
    return created;
  }

  /// Convenience method to create an event from individual parameters.
  Future<EventModel> createEventFromParams({
    required String title,
    required String subtitle,
    required DateTime date,
    String? description,
    String? venue,
    String? city,
    String? country,
    String? imageUrl,
    int? priceInCents,
    String? currency,
    String? category,
    List<String>? tags,
    int? noiseSeed,
    bool hideLocation = false,
  }) async {
    final event = EventModel(
      id: '', // Will be generated by database
      title: title,
      subtitle: subtitle,
      description: description,
      date: date,
      venue: venue,
      city: city,
      country: country,
      imageUrl: imageUrl,
      priceInCents: priceInCents,
      currency: currency ?? 'USD',
      category: category,
      tags: tags ?? const [],
      noiseSeed: noiseSeed ?? DateTime.now().millisecondsSinceEpoch % 10000,
      hideLocation: hideLocation,
    );
    return createEvent(event);
  }

  @override
  Future<EventModel> updateEvent(EventModel event) async {
    AppLogger.debug('Updating event: ${event.id}', tag: _tag);

    final data = EventMapper.toJson(event);
    data['updated_at'] = DateTime.now().toUtc().toIso8601String();

    final response = await _client
        .from(_tableName)
        .update(data)
        .eq('id', event.id)
        .select()
        .single();

    final updated = EventMapper.fromJson(response);
    AppLogger.info('Event updated: ${updated.id} - ${updated.title}', tag: _tag);
    return updated;
  }

  @override
  Future<void> deleteEvent(String id) async {
    AppLogger.debug('Soft-deleting event: $id', tag: _tag);

    await _client.from(_tableName).update({
      'deleted_at': DateTime.now().toUtc().toIso8601String(),
    }).eq('id', id);

    AppLogger.info('Event deleted: $id', tag: _tag);
  }

  @override
  Future<PaginatedResult<EventModel>> getMyEvents({
    MyEventsDateFilter dateFilter = MyEventsDateFilter.recent,
    String? searchQuery,
    int page = 0,
    int pageSize = 20,
  }) async {
    final userId = SupabaseService.instance.currentUser?.id;
    if (userId == null) {
      AppLogger.warning('Attempted to get my events without authentication', tag: _tag);
      throw StateError('Must be authenticated to view your events');
    }

    // Convert enum to string for RPC
    final dateFilterStr = switch (dateFilter) {
      MyEventsDateFilter.recent => 'recent',
      MyEventsDateFilter.upcoming => 'upcoming',
      MyEventsDateFilter.all => 'all',
      MyEventsDateFilter.past => 'past',
    };

    // Trim and normalize search query
    final normalizedSearch = searchQuery?.trim().isNotEmpty == true
        ? searchQuery!.trim()
        : null;

    AppLogger.debug(
      'Fetching events for user: $userId (filter: $dateFilterStr, search: $normalizedSearch, page: $page, pageSize: $pageSize)',
      tag: _tag,
    );

    final offset = page * pageSize;

    // Use RPC function for server-side filtering and sorting
    final response = await _client.rpc(
      'get_my_events',
      params: {
        'p_user_id': userId,
        'p_date_filter': dateFilterStr,
        'p_search_query': normalizedSearch,
        'p_limit': pageSize + 1, // Fetch one extra to check hasMore
        'p_offset': offset,
      },
    );

    final allItems = (response as List<dynamic>)
        .map((json) => EventMapper.fromJson(json as Map<String, dynamic>))
        .toList();

    final hasMore = allItems.length > pageSize;
    final events = hasMore ? allItems.take(pageSize).toList() : allItems;

    AppLogger.debug(
      'Fetched ${events.length} user events (hasMore: $hasMore)',
      tag: _tag,
    );

    return PaginatedResult(
      items: events,
      page: page,
      pageSize: pageSize,
      hasMore: hasMore,
    );
  }

  @override
  Future<TicketAvailability> getTicketAvailability(String eventId) async {
    AppLogger.debug('Fetching ticket availability for event: $eventId', tag: _tag);

    // Call the RPC function for SQL aggregation
    final response = await _client.rpc(
      'get_ticket_availability',
      params: {'p_event_id': eventId},
    );

    if (response == null) {
      AppLogger.debug('No availability data for event: $eventId', tag: _tag);
      return const TicketAvailability(soldCount: 0);
    }

    final data = response as Map<String, dynamic>;
    AppLogger.debug(
      'Ticket availability: max=${data['max_tickets']}, sold=${data['sold_count']}, available=${data['available']}',
      tag: _tag,
    );

    return TicketAvailability.fromJson(data);
  }

  /// Get all ticket types for an event.
  Future<List<TicketType>> getEventTicketTypes(String eventId) async {
    AppLogger.debug('Fetching ticket types for event: $eventId', tag: _tag);

    final response = await _client.rpc(
      'get_event_ticket_types',
      params: {'p_event_id': eventId},
    );

    final ticketTypes = (response as List<dynamic>)
        .map((json) => TicketType.fromJson(json as Map<String, dynamic>))
        .toList();

    AppLogger.debug('Fetched ${ticketTypes.length} ticket types', tag: _tag);
    return ticketTypes;
  }

  /// Create ticket types for an event.
  Future<List<TicketType>> createTicketTypes(
    String eventId,
    List<TicketTypeInput> ticketTypes,
  ) async {
    if (ticketTypes.isEmpty) {
      AppLogger.debug('No ticket types to create for event: $eventId', tag: _tag);
      return [];
    }

    AppLogger.debug(
      'Creating ${ticketTypes.length} ticket types for event: $eventId',
      tag: _tag,
    );

    final data = ticketTypes.asMap().entries.map((entry) {
      final index = entry.key;
      final tt = entry.value;
      return {
        'event_id': eventId,
        'name': tt.name,
        'description': tt.description,
        'price_cents': tt.priceCents,
        'max_quantity': tt.maxQuantity,
        'sort_order': index,
        'is_active': true,
      };
    }).toList();

    final response = await _client
        .from('event_ticket_types')
        .insert(data)
        .select();

    final created = (response as List<dynamic>)
        .map((json) => TicketType.fromJson(json as Map<String, dynamic>))
        .toList();

    AppLogger.info('Created ${created.length} ticket types for event: $eventId', tag: _tag);
    return created;
  }

  /// Create an event with ticket types in a single operation.
  Future<EventModel> createEventWithTicketTypes({
    required String title,
    required String subtitle,
    required DateTime date,
    required List<TicketTypeInput> ticketTypes,
    String? description,
    String? venue,
    String? city,
    String? country,
    String? imageUrl,
    String? currency,
    String? category,
    List<String>? tags,
    int? noiseSeed,
    bool hideLocation = false,
  }) async {
    // Use the lowest ticket price as the event's display price
    final lowestPrice = ticketTypes.isEmpty
        ? null
        : ticketTypes.map((t) => t.priceCents).reduce((a, b) => a < b ? a : b);

    // Create the event first
    final event = await createEventFromParams(
      title: title,
      subtitle: subtitle,
      date: date,
      description: description,
      venue: venue,
      city: city,
      country: country,
      imageUrl: imageUrl,
      priceInCents: lowestPrice,
      currency: currency,
      category: category,
      tags: tags,
      noiseSeed: noiseSeed,
      hideLocation: hideLocation,
    );

    // Then create the ticket types
    if (ticketTypes.isNotEmpty) {
      await createTicketTypes(event.id, ticketTypes);
    }

    return event;
  }
}
