import '../../../core/services/services.dart';
import '../models/event_model.dart';
import 'event_mapper.dart';
import 'event_repository.dart';

/// Supabase implementation of [EventRepository].
///
/// Fetches and manages events from the Supabase PostgreSQL database.
class SupabaseEventRepository implements EventRepository {
  static const _tableName = 'events';

  final _client = SupabaseService.instance.client;

  @override
  Future<List<EventModel>> getUpcomingEvents({
    String? category,
    String? city,
    int? limit,
  }) async {
    // Build query with filters first, then ordering and limit
    var query = _client
        .from(_tableName)
        .select()
        .isFilter('deleted_at', null)
        .gte('date', DateTime.now().toUtc().toIso8601String());

    if (category != null) {
      query = query.eq('category', category);
    }
    if (city != null) {
      query = query.eq('city', city);
    }

    // Apply ordering after all filters
    final orderedQuery = query.order('date', ascending: true);

    // Apply limit if specified
    final response = limit != null
        ? await orderedQuery.limit(limit)
        : await orderedQuery;

    return (response as List<dynamic>)
        .map((json) => EventMapper.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  @override
  Future<EventModel?> getEventById(String id) async {
    final response = await _client
        .from(_tableName)
        .select()
        .eq('id', id)
        .isFilter('deleted_at', null)
        .maybeSingle();

    if (response == null) return null;
    return EventMapper.fromJson(response);
  }

  @override
  Future<List<EventModel>> getFeaturedEvents({int limit = 5}) async {
    // For now, just get the nearest upcoming events as featured
    // In production, you might have a "featured" flag or algorithm
    final response = await _client
        .from(_tableName)
        .select()
        .isFilter('deleted_at', null)
        .gte('date', DateTime.now().toUtc().toIso8601String())
        .order('date', ascending: true)
        .limit(limit);

    return (response as List<dynamic>)
        .map((json) => EventMapper.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  @override
  Future<EventModel> createEvent(EventModel event) async {
    final userId = SupabaseService.instance.currentUser?.id;
    if (userId == null) {
      throw StateError('Must be authenticated to create events');
    }

    final data = EventMapper.toJson(event);
    data['organizer_id'] = userId;

    final response =
        await _client.from(_tableName).insert(data).select().single();

    return EventMapper.fromJson(response);
  }

  /// Convenience method to create an event from individual parameters.
  Future<EventModel> createEventFromParams({
    required String title,
    required String subtitle,
    required DateTime date,
    String? description,
    String? venue,
    String? city,
    String? country,
    String? imageUrl,
    int? priceInCents,
    String? currency,
    String? category,
    int? noiseSeed,
  }) async {
    final event = EventModel(
      id: '', // Will be generated by database
      title: title,
      subtitle: subtitle,
      description: description,
      date: date,
      venue: venue,
      city: city,
      country: country,
      imageUrl: imageUrl,
      priceInCents: priceInCents,
      currency: currency ?? 'USD',
      category: category,
      noiseSeed: noiseSeed ?? DateTime.now().millisecondsSinceEpoch % 10000,
    );
    return createEvent(event);
  }

  @override
  Future<EventModel> updateEvent(EventModel event) async {
    final data = EventMapper.toJson(event);
    data['updated_at'] = DateTime.now().toUtc().toIso8601String();

    final response = await _client
        .from(_tableName)
        .update(data)
        .eq('id', event.id)
        .select()
        .single();

    return EventMapper.fromJson(response);
  }

  @override
  Future<void> deleteEvent(String id) async {
    await _client.from(_tableName).update({
      'deleted_at': DateTime.now().toUtc().toIso8601String(),
    }).eq('id', id);
  }

  @override
  Future<List<EventModel>> getMyEvents() async {
    final userId = SupabaseService.instance.currentUser?.id;
    if (userId == null) {
      throw StateError('Must be authenticated to view your events');
    }

    final response = await _client
        .from(_tableName)
        .select()
        .eq('organizer_id', userId)
        .isFilter('deleted_at', null)
        .order('date', ascending: true);

    return (response as List<dynamic>)
        .map((json) => EventMapper.fromJson(json as Map<String, dynamic>))
        .toList();
  }
}
